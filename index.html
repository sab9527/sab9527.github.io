<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>費西亞遺產神像模擬器（sab版）</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Cinzel', serif;
      background: url('https://web.poecdn.com/protected/image/layout/settlersofkalguur-bg.jpg?v=1739989996052&key=iTGamUssLclxKShOx2gEuw') no-repeat center center fixed;
      background-size: cover;
      color: #d4af37;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    header {
      text-align: center;
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 30px;
      color: #d4af37;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    #controls {
      text-align: center;
      margin-bottom: 30px;
    }
    #controls button {
      margin: 0 8px;
      padding: 8px 16px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      background: linear-gradient(to bottom, #d4af37, #a67c00);
      color: #fff;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.2s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    #controls button:hover {
      background: linear-gradient(to bottom, #a67c00, #d4af37);
      transform: translateY(-2px);
    }
    #container {
      max-width: 1200px;
      margin: auto;
      display: flex;
      flex-direction: column;
      gap: 30px;
    }
    #play-area {
      display: flex;
      align-items: flex-start;
      gap: 95px;
      flex-wrap: nowrap;
      width: 100%;
      box-sizing: border-box;
    }
    #grid {
      width: 300px;
      height: 350px;
      position: relative;
      border-radius: 8px;
      background-color: #333;
      border: 3px solid #a67c00;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }
    #supply {
      max-width: 800px;
      min-height: 300px;
      border-radius: 8px;
      background-color: #333;
      border: 3px solid #a67c00;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
    }
    #supply h3 {
      margin-top: 0;
      text-align: center;
      color: #d4af37;
    }
    .supply-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
    }
    .supply-row {
      flex: 1 1 calc(25% - 15px);
      box-sizing: border-box;
      min-width: 160px;
      max-width: 250px;
      border: 1px dashed #a67c00;
      padding: 10px;
      border-radius: 6px;
      background-color: #444;
      margin-bottom: 10px;
      transition: background-color 0.3s;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
    }
    .supply-row:hover {
      background-color: #555;
    }
    .supply-label {
      font-size: 16px;
      margin-bottom: 6px;
      text-align: left;
      color: #d4af37;
    }
    .supply-content {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    .supply-content select {
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      background: #555;
      color: #d4af37;
      border: 1px solid #a67c00;
      padding: 4px;
    }
    .supply-content input[type="text"] {
      width: 100%;
      padding: 4px;
      background: #555;
      color: #d4af37;
      border: 1px solid #a67c00;
    }
    .block, .placed-block {
      position: absolute;
      background: linear-gradient(to bottom, #d4af37, #a67c00);
      border: 2px solid #a67c00;
      border-radius: 6px;
      cursor: move;
      box-sizing: border-box;
      z-index: 10;
      overflow: hidden;
      transition: transform 0.2s, box-shadow 0.3s, left 0.1s ease, top 0.1s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }
    .block:hover, .placed-block:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
    }
    .supply-row .block {
      position: static;
    }
    .grid-cell {
      position: absolute;
      width: 50px;
      height: 50px;
      border: 1px solid #a67c00;
      background-color: #333;
      box-sizing: border-box;
      text-align: center;
      user-select: none;
      transition: background-color 0.3s;
    }
    .grid-cell:hover {
      background-color: #444;
    }
    .grid-cell.disabled {
      background-color: #222;
      color: #d4af37;
      font-size: 24px;
      text-align: center;
      line-height: 50px;
    }
    #stats {
      background-color: #333;
      border: 3px solid #a67c00;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      padding: 10px;
      margin-top: 20px;
    }
    #stats h3 {
      margin-top: 0;
      text-align: center;
      color: #d4af37;
    }
    #stats table {
      width: 100%;
      border-collapse: collapse;
    }
    #stats th, #stats td {
      border: 1px solid #a67c00;
      padding: 8px;
      text-align: center;
      vertical-align: middle;
      color: #d4af37;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: #333;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 600px;
      position: relative;
      color: #d4af37;
      border: 2px solid #a67c00;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
    }
    .close-button {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      cursor: pointer;
      color: #d4af37;
    }
    #toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: #d4af37;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      display: none;
    }
    #grid-note {
      text-align: center;
      margin-top: 10px;
      font-size: 14px;
      color: #d4af37;
    }
  </style>
</head>
<body>
  <header>費西亞的遺產 神像模擬器（sab）</header>
  <div id="container">
    <div id="controls">
      <button id="reset-btn">重置放置區</button>
      <button id="show-data-btn">顯示神像資料</button>
      <button id="compact-btn">自動排列積木</button>
      <button id="mode-115-btn">115模式</button>
    </div>
    <div id="play-area">
      <div id="grid"></div>
      <div id="supply">
        <h3>神像選擇區</h3>
        <div id="supply-group" class="supply-group"></div>
      </div>
    </div>
    <div id="grid-note">盡量拖曳方塊的中間，如果多次無法拖曳到指定位置建議重做一個神像</div>
    <div id="stats">
      <h3>統計</h3>
      <table id="statsTable">
        <thead>
          <tr>
            <th>神像效果</th>
            <th>數量</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
  <div id="modal" class="modal">
    <div class="modal-content">
      <span class="close-button">×</span>
      <h2>神像資料</h2>
      <div id="modal-body"></div>
    </div>
  </div>
  <div id="toast"></div>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const cellSize = 50;
      const cols = 6;
      const rows = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
      const disabledCells = ["1A", "2C", "5C", "2D", "3D", "4D", "5D", "2E", "5E", "6G"];
      const grid = document.getElementById("grid");
      const gridStatus = Array.from({ length: rows.length }, () => Array(cols).fill('empty'));
      disabledCells.forEach(cell => {
        const [col, row] = cell.split('');
        gridStatus[rows.indexOf(row)][parseInt(col) - 1] = 'disabled';
      });

      rows.forEach((r, rowIndex) => {
        for (let col = 1; col <= cols; col++) {
          const cell = document.createElement("div");
          cell.classList.add("grid-cell");
          cell.style.left = ((col - 1) * cellSize) + "px";
          cell.style.top = (rowIndex * cellSize) + "px";
          cell.setAttribute("data-col", col);
          cell.setAttribute("data-row", r);
          if (gridStatus[rowIndex][col - 1] === 'disabled') {
            cell.classList.add("disabled");
            cell.innerText = "🚫";
          }
          cell.addEventListener("dragover", e => e.preventDefault());
          cell.addEventListener("drop", handleDrop);
          grid.appendChild(cell);
        }
      });

      const stats = {};

      const suffixOptions = {
        "1x1": ["你的地圖 +(15–25)% 機率含有 1 個深淵"],
        "1x2": ["你的地圖 +(30–45)% 機率含有 1 個深淵"],
        "1x3": ["你的地圖 +(40–60)% 機率含有 1 個深淵"],
        "2x2": ["你地圖 +(45–70)% 機率含有 1 個深淵"]
      };
      const prefixOptions = {
        "1x1": ["你地圖中的深淵保險箱和冥河之尖，增加 (15–25)% 機率含有或掉落 1 個深淵珠寶"],
        "1x2": ["你地圖中的深淵增加 (12–18)% 怪物生成"],
        "1x3": ["你的地圖中不會前往絕望深淵的深淵，增加 (40–60)% 機率前往冥河之尖"],
        "2x2": ["你的地圖中深淵保險箱或冥河之尖掉落的深淵珠寶，有 (15–25)% 機率為已汙染且有 5 或 6 個隨機詞綴"]
      };
      const legendSuffixOptions = {
        "1x1": ["巨靈之眼 次要魔偶-你的地圖上的聖甲蟲效果會根據每個空地圖裝置欄位增加 50%"],
        "1x2": ["傳奇效果A", "傳奇效果B"],
        "1x3": ["傳奇效果C", "傳奇效果D"],
        "2x2": ["傳奇效果E", "傳奇效果F"]
      };
      const blocks = [
        { w: 1, h: 1, label: "次要", type: "minor" },
        { w: 1, h: 1, label: "傳奇", type: "legend" },
        { w: 2, h: 1, label: "高貴", type: "normal" },
        { w: 1, h: 2, label: "卡瑪薩", type: "normal" },
        { w: 3, h: 1, label: "埋葬", type: "normal" },
        { w: 1, h: 3, label: "圖騰", type: "normal" },
        { w: 2, h: 2, label: "征服者", type: "normal" }
      ];

      const supplyGroup = document.getElementById("supply-group");

      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.style.display = "block";
        setTimeout(() => toast.style.display = "none", 2000);
      }

      function getGroupKey(w, h) {
        if ((w === 2 && h === 1) || (w === 1 && h === 2)) return "1x2";
        if ((w === 3 && h === 1) || (w === 1 && h === 3)) return "1x3";
        if (w === 2 && h === 2) return "2x2";
        return "1x1";
      }

      function attachSearchListener(searchInput, contentDiv) {
        searchInput.addEventListener("input", function () {
          const term = this.value.trim().toLowerCase();
          contentDiv.querySelectorAll("select").forEach((select, idx) => {
            const originalOpts = JSON.parse(select.dataset.originalOptions);
            const currentValue = select.value;
            select.options.length = 0;
            const defaultOption = document.createElement("option");
            defaultOption.value = "";
            defaultOption.text = "效果" + (idx + 1);
            select.appendChild(defaultOption);
            originalOpts.forEach(text => {
              if (term === "" || text.toLowerCase().includes(term) || text === currentValue) {
                const opt = document.createElement("option");
                opt.value = text;
                opt.text = text;
                select.appendChild(opt);
              }
            });
            if (currentValue) select.value = currentValue;
          });
        });
      }

      blocks.forEach(block => {
        const rowDiv = document.createElement("div");
        rowDiv.classList.add("supply-row");
        const label = document.createElement("div");
        label.classList.add("supply-label");
        label.textContent = block.label;
        const content = document.createElement("div");
        content.classList.add("supply-content");
        const blk = document.createElement("div");
        blk.classList.add("block");
        blk.setAttribute("draggable", "true");
        blk.dataset.w = block.w;
        blk.dataset.h = block.h;
        blk.dataset.type = block.type;
        blk.style.width = (block.w * cellSize - 4) + "px";
        blk.style.height = (block.h * cellSize - 4) + "px";

        const groupKey = (block.w === 2 && block.h === 1 && block.label === "高貴") ? "1x1" : getGroupKey(block.w, block.h);
        const searchInput = document.createElement("input");
        searchInput.type = "text";
        searchInput.placeholder = "搜尋...";

        if (block.type === "minor") {
          const suffixOpts = suffixOptions["1x1"];
          const prefixOpts = prefixOptions["1x1"];
          const select1 = document.createElement("select");
          select1.dataset.originalOptions = JSON.stringify(suffixOpts);
          const defaultOption1 = document.createElement("option");
          defaultOption1.value = "";
          defaultOption1.text = "效果1";
          select1.appendChild(defaultOption1);
          suffixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select1.appendChild(option);
          });

          const select2 = document.createElement("select");
          select2.dataset.originalOptions = JSON.stringify(suffixOpts);
          const defaultOption2 = document.createElement("option");
          defaultOption2.value = "";
          defaultOption2.text = "效果2";
          select2.appendChild(defaultOption2);
          suffixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select2.appendChild(option);
          });

          const select3 = document.createElement("select");
          select3.dataset.originalOptions = JSON.stringify(prefixOpts);
          const defaultOption3 = document.createElement("option");
          defaultOption3.value = "";
          defaultOption3.text = "效果3";
          select3.appendChild(defaultOption3);
          prefixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select3.appendChild(option);
          });

          const select4 = document.createElement("select");
          select4.dataset.originalOptions = JSON.stringify(prefixOpts);
          const defaultOption4 = document.createElement("option");
          defaultOption4.value = "";
          defaultOption4.text = "效果4";
          select4.appendChild(defaultOption4);
          prefixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select4.appendChild(option);
          });

          blk.addEventListener("dragstart", function (e) {
            const data = {
              w: parseInt(blk.dataset.w),
              h: parseInt(blk.dataset.h),
              info1: select1.value,
              info2: select2.value,
              info3: select3.value,
              info4: select4.value,
              type: blk.dataset.type
            };
            e.dataTransfer.setData("text/plain", JSON.stringify(data));
          });

          attachSearchListener(searchInput, content);
          content.appendChild(blk);
          content.appendChild(searchInput);
          content.appendChild(select1);
          content.appendChild(select2);
          content.appendChild(select3);
          content.appendChild(select4);
        } else if (block.type === "legend") {
          const legendOpts = legendSuffixOptions[groupKey];
          const select1 = document.createElement("select");
          select1.dataset.originalOptions = JSON.stringify(legendOpts);
          const defaultOption1 = document.createElement("option");
          defaultOption1.value = "";
          defaultOption1.text = "效果1";
          select1.appendChild(defaultOption1);
          legendOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select1.appendChild(option);
          });

          blk.addEventListener("dragstart", function (e) {
            const data = {
              w: parseInt(blk.dataset.w),
              h: parseInt(blk.dataset.h),
              info1: select1.value,
              type: blk.dataset.type
            };
            e.dataTransfer.setData("text/plain", JSON.stringify(data));
          });

          attachSearchListener(searchInput, content);
          content.appendChild(blk);
          content.appendChild(searchInput);
          content.appendChild(select1);
        } else {
          const suffixOpts = suffixOptions[groupKey].slice(0, 99);
          const prefixOpts = prefixOptions[groupKey].slice(0, 99);
          const select1 = document.createElement("select");
          select1.dataset.originalOptions = JSON.stringify(suffixOpts);
          const defaultOption1 = document.createElement("option");
          defaultOption1.value = "";
          defaultOption1.text = "效果1";
          select1.appendChild(defaultOption1);
          suffixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select1.appendChild(option);
          });

          const select2 = document.createElement("select");
          select2.dataset.originalOptions = JSON.stringify(suffixOpts);
          const defaultOption2 = document.createElement("option");
          defaultOption2.value = "";
          defaultOption2.text = "效果2";
          select2.appendChild(defaultOption2);
          suffixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select2.appendChild(option);
          });

          const select3 = document.createElement("select");
          select3.dataset.originalOptions = JSON.stringify(prefixOpts);
          const defaultOption3 = document.createElement("option");
          defaultOption3.value = "";
          defaultOption3.text = "效果3";
          select3.appendChild(defaultOption3);
          prefixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select3.appendChild(option);
          });

          const select4 = document.createElement("select");
          select4.dataset.originalOptions = JSON.stringify(prefixOpts);
          const defaultOption4 = document.createElement("option");
          defaultOption4.value = "";
          defaultOption4.text = "效果4";
          select4.appendChild(defaultOption4);
          prefixOpts.forEach(text => {
            const option = document.createElement("option");
            option.value = text;
            option.text = text;
            select4.appendChild(option);
          });

          blk.addEventListener("dragstart", function (e) {
            const data = {
              w: parseInt(blk.dataset.w),
              h: parseInt(blk.dataset.h),
              info1: select1.value,
              info2: select2.value,
              info3: select3.value,
              info4: select4.value,
              type: blk.dataset.type
            };
            e.dataTransfer.setData("text/plain", JSON.stringify(data));
          });

          attachSearchListener(searchInput, content);
          content.appendChild(blk);
          content.appendChild(searchInput);
          content.appendChild(select1);
          content.appendChild(select2);
          content.appendChild(select3);
          content.appendChild(select4);
        }

        rowDiv.appendChild(label);
        rowDiv.appendChild(content);
        supplyGroup.appendChild(rowDiv);
      });

      function updateStats() {
        const statsTableBody = document.querySelector("#statsTable tbody");
        statsTableBody.innerHTML = "";
        for (let info in stats) {
          const tr = document.createElement("tr");
          const tdInfo = document.createElement("td");
          tdInfo.textContent = info;
          const tdCount = document.createElement("td");
          tdCount.textContent = stats[info] + " 個";
          tr.appendChild(tdInfo);
          tr.appendChild(tdCount);
          statsTableBody.appendChild(tr);
        }
      }

      function handleDrop(e) {
        e.preventDefault();
        const dataText = e.dataTransfer.getData("text/plain");
        if (!dataText) return;
        const blockData = JSON.parse(dataText);
        const targetCell = e.target.closest('.grid-cell');
        if (!targetCell) return;
        const startCol = parseInt(targetCell.getAttribute("data-col"));
        const startRow = rows.indexOf(targetCell.getAttribute("data-row"));
        const w = blockData.w;
        const h = blockData.h;

        if (canPlace(startRow, startCol, w, h)) {
          placeBlock(startRow, startCol, blockData);
        } else {
          const position = findNearestPosition(startRow, startCol, w, h);
          if (position) placeBlock(position.row, position.col, blockData);
          else showToast("無法放置積木！");
        }
      }

      function canPlace(row, col, w, h) {
        if (row < 0 || row + h > rows.length || col < 1 || col + w - 1 > cols) return false;
        for (let r = row; r < row + h; r++) {
          for (let c = col - 1; c < col + w - 1; c++) {
            if (gridStatus[r][c] !== 'empty') return false;
          }
        }
        return true;
      }

      function findNearestPosition(startRow, startCol, w, h) {
        for (let r = 0; r <= rows.length - h; r++) {
          for (let c = 0; c <= cols - w; c++) {
            if (canPlace(r, c + 1, w, h)) return { row: r, col: c + 1 };
          }
        }
        return null;
      }

      function placeBlock(row, col, blockData) {
        const placed = document.createElement("div");
        placed.classList.add("placed-block");
        placed.style.width = (blockData.w * cellSize - 4) + "px";
        placed.style.height = (blockData.h * cellSize - 4) + "px";
        placed.style.left = ((col - 1) * cellSize) + "px";
        placed.style.top = (row * cellSize) + "px";
        placed.dataset.col = col;
        placed.dataset.row = row;
        placed.dataset.w = blockData.w;
        placed.dataset.h = blockData.h;
        placed.dataset.info1 = blockData.info1 || "";
        placed.dataset.info2 = blockData.info2 || "";
        placed.dataset.info3 = blockData.info3 || "";
        placed.dataset.info4 = blockData.info4 || "";
        placed.style.backgroundColor = blockData.type === "legend" ? "orange" : blockData.type === "minor" ? "lightgreen" : "lavender";

        for (let r = row; r < row + blockData.h; r++) {
          for (let c = col - 1; c < col + blockData.w - 1; c++) {
            gridStatus[r][c] = 'occupied';
          }
        }
        if (blockData.info1) stats[blockData.info1] = (stats[blockData.info1] || 0) + 1;
        if (blockData.info2) stats[blockData.info2] = (stats[blockData.info2] || 0) + 1;
        if (blockData.info3) stats[blockData.info3] = (stats[blockData.info3] || 0) + 1;
        if (blockData.info4) stats[blockData.info4] = (stats[blockData.info4] || 0) + 1;
        updateStats();
        addDraggable(placed);
        grid.appendChild(placed);
        saveState();
      }

      function addDraggable(el) {
        let isDragging = false;
        let startX, startY, origLeft, origTop;
        el.addEventListener("mousedown", function (e) {
          if (e.button !== 0) return;
          isDragging = false;
          startX = e.clientX;
          startY = e.clientY;
          origLeft = parseInt(el.style.left, 10);
          origTop = parseInt(el.style.top, 10);
          e.preventDefault();

          function onMouseMove(e) {
            let dx = e.clientX - startX;
            let dy = e.clientY - startY;
            if (Math.abs(dx) > 5 || Math.abs(dy) > 5) isDragging = true;
            el.style.left = (origLeft + dx) + "px";
            el.style.top = (origTop + dy) + "px";
          }

          function onMouseUp(e) {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            if (isDragging) {
              let newLeft = parseInt(el.style.left, 10);
              let newTop = parseInt(el.style.top, 10);
              let newCol = Math.round(newLeft / cellSize) + 1;
              let newRow = Math.round(newTop / cellSize);
              let w = parseInt(el.dataset.w);
              let h = parseInt(el.dataset.h);

              if (canPlace(newRow, newCol, w, h)) {
                for (let r = parseInt(el.dataset.row); r < parseInt(el.dataset.row) + h; r++) {
                  for (let c = parseInt(el.dataset.col) - 1; c < parseInt(el.dataset.col) + w - 1; c++) {
                    gridStatus[r][c] = 'empty';
                  }
                }
                el.dataset.col = newCol;
                el.dataset.row = newRow;
                for (let r = newRow; r < newRow + h; r++) {
                  for (let c = newCol - 1; c < newCol + w - 1; c++) {
                    gridStatus[r][c] = 'occupied';
                  }
                }
                el.style.left = ((newCol - 1) * cellSize) + "px";
                el.style.top = (newRow * cellSize) + "px";
                saveState();
              } else {
                el.style.left = origLeft + "px";
                el.style.top = origTop + "px";
                showToast("無法移動至此位置！");
              }
            }
          }
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });

        el.addEventListener("click", function (e) {
          if (isDragging) return;
          let col = parseInt(el.dataset.col);
          let row = parseInt(el.dataset.row);
          let w = parseInt(el.dataset.w);
          let h = parseInt(el.dataset.h);
          for (let r = row; r < row + h; r++) {
            for (let c = col - 1; c < col + w - 1; c++) {
              gridStatus[r][c] = 'empty';
            }
          }
          if (el.dataset.info1) stats[el.dataset.info1] = (stats[el.dataset.info1] || 0) - 1;
          if (el.dataset.info2) stats[el.dataset.info2] = (stats[el.dataset.info2] || 0) - 1;
          if (el.dataset.info3) stats[el.dataset.info3] = (stats[el.dataset.info3] || 0) - 1;
          if (el.dataset.info4) stats[el.dataset.info4] = (stats[el.dataset.info4] || 0) - 1;
          for (let key in stats) if (stats[key] <= 0) delete stats[key];
          updateStats();
          el.remove();
          saveState();
        });
      }

      let is115Mode = false;
      document.getElementById("mode-115-btn").addEventListener("click", function () {
        is115Mode = !is115Mode;
        const cell6A = document.querySelector('.grid-cell[data-col="6"][data-row="A"]');
        if (is115Mode) {
          cell6A.classList.add("disabled");
          cell6A.innerText = "🚫";
          gridStatus[0][5] = 'disabled';
          const blockOn6A = Array.from(document.querySelectorAll('.placed-block')).find(block => {
            const col = parseInt(block.dataset.col);
            const row = parseInt(block.dataset.row);
            const w = parseInt(block.dataset.w);
            const h = parseInt(block.dataset.h);
            return row <= 0 && row + h - 1 >= 0 && col <= 6 && col + w - 1 >= 6;
          });
          if (blockOn6A) {
            const w = parseInt(blockOn6A.dataset.w);
            const h = parseInt(blockOn6A.dataset.h);
            const position = findNearestPosition(0, 1, w, h);
            if (position) {
              for (let r = parseInt(blockOn6A.dataset.row); r < parseInt(blockOn6A.dataset.row) + h; r++) {
                for (let c = parseInt(blockOn6A.dataset.col) - 1; c < parseInt(blockOn6A.dataset.col) + w - 1; c++) {
                  gridStatus[r][c] = 'empty';
                }
              }
              blockOn6A.dataset.col = position.col;
              blockOn6A.dataset.row = position.row;
              blockOn6A.style.left = ((position.col - 1) * cellSize) + "px";
              blockOn6A.style.top = (position.row * cellSize) + "px";
              for (let r = position.row; r < position.row + h; r++) {
                for (let c = position.col - 1; c < position.col + w - 1; c++) {
                  gridStatus[r][c] = 'occupied';
                }
              }
              saveState();
            } else {
              showToast("無法移動積木，請手動調整！");
            }
          }
        } else {
          cell6A.classList.remove("disabled");
          cell6A.innerText = "";
          gridStatus[0][5] = 'empty';
        }
      });

      function resetGrid() {
        document.querySelectorAll(".placed-block").forEach(block => block.remove());
        for (let r = 0; r < rows.length; r++) {
          for (let c = 0; c < cols; c++) {
            if (gridStatus[r][c] !== 'disabled') gridStatus[r][c] = 'empty';
          }
        }
        for (const key in stats) delete stats[key];
        updateStats();
        saveState();
      }

      function showData() {
        const blocks = document.querySelectorAll(".placed-block");
        if (blocks.length === 0) {
          showToast("放置區內沒有神像！");
          return;
        }
        const modal = document.getElementById("modal");
        const modalBody = document.getElementById("modal-body");
        let htmlContent = "<ul>";
        let index = 1;
        blocks.forEach(block => {
          htmlContent += `<li><strong>神像 ${index}:</strong> `;
          let effects = [];
          if (block.dataset.info1) effects.push(block.dataset.info1);
          if (block.dataset.info2) effects.push(block.dataset.info2);
          if (block.dataset.info3) effects.push(block.dataset.info3);
          if (block.dataset.info4) effects.push(block.dataset.info4);
          htmlContent += effects.join(", ") + "</li>";
          index++;
        });
        htmlContent += "</ul>";
        modalBody.innerHTML = htmlContent;
        modal.style.display = "flex";
      }

      function autoArrange() {
        const blocks = Array.from(document.querySelectorAll(".placed-block"));
        if (blocks.length === 0) return;

        for (let r = 0; r < rows.length; r++) {
          for (let c = 0; c < cols; c++) {
            if (gridStatus[r][c] !== 'disabled') gridStatus[r][c] = 'empty';
          }
        }

        blocks.sort((a, b) => {
          const areaA = parseInt(a.dataset.w) * parseInt(a.dataset.h);
          const areaB = parseInt(b.dataset.w) * parseInt(b.dataset.h);
          return areaB - areaA;
        });

        blocks.forEach(block => {
          const w = parseInt(block.dataset.w);
          const h = parseInt(block.dataset.h);
          let placed = false;

          for (let r = 0; r <= rows.length - h && !placed; r++) {
            for (let c = 0; c <= cols - w && !placed; c++) {
              if (canPlace(r, c + 1, w, h)) {
                block.dataset.col = c + 1;
                block.dataset.row = r;
                block.style.left = (c * cellSize) + "px";
                block.style.top = (r * cellSize) + "px";
                for (let i = r; i < r + h; i++) {
                  for (let j = c; j < c + w; j++) {
                    gridStatus[i][j] = 'occupied';
                  }
                }
                placed = true;
              }
            }
          }

          if (!placed) showToast("無法自動排列所有神像，請手動調整！");
        });
        saveState();
      }

      function saveState() {
        const blocks = Array.from(document.querySelectorAll(".placed-block")).map(block => ({
          col: block.dataset.col,
          row: block.dataset.row,
          w: block.dataset.w,
          h: block.dataset.h,
          info1: block.dataset.info1,
          info2: block.dataset.info2,
          info3: block.dataset.info3,
          info4: block.dataset.info4,
          type: block.style.backgroundColor === "orange" ? "legend" : block.style.backgroundColor === "lightgreen" ? "minor" : "normal"
        }));
        localStorage.setItem("placedBlocks", JSON.stringify(blocks));
      }

      function loadState() {
        const blocks = JSON.parse(localStorage.getItem("placedBlocks") || "[]");
        blocks.forEach(blockData => placeBlock(parseInt(blockData.row), parseInt(blockData.col), blockData));
      }

      document.getElementById("reset-btn").addEventListener("click", resetGrid);
      document.getElementById("show-data-btn").addEventListener("click", showData);
      document.getElementById("compact-btn").addEventListener("click", autoArrange);
      document.addEventListener("keydown", function(e) {
        if (e.key === "r" || e.key === "R") resetGrid();
        else if (e.key === "d" || e.key === "D") showData();
      });
      document.querySelector(".close-button").addEventListener("click", function() {
        document.getElementById("modal").style.display = "none";
      });
      window.addEventListener("click", function(event) {
        const modal = document.getElementById("modal");
        if (event.target === modal) modal.style.display = "none";
      });
      window.addEventListener("load", loadState);
    });
  </script>
</body>
</html>
